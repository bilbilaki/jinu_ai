// lib/presentation/providers/chat_providers.dart
import 'package:flutter/material.dart'; // For debugPrint
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import 'api_providers.dart';
import 'history_provider.dart';
import 'settings_provider.dart';
import '../../data/models/chat_message.dart';
import '../../data/models/chat_session_item.dart';
import '../../data/services/openai_chat_service.dart'; // For convertToOpenAIMessage helper
import '../../data/services/chat_history_service.dart'; // To access methods directly
import 'package:dart_openai/dart_openai.dart'; // Fpr OpenAIChatCompletionChoiceMessageModel


const uuid = Uuid();

// Provider to indicate if the AI is currently processing a message
final isLoadingProvider = StateProvider<bool>((ref) => false);


// --- Main Chat Controller ---
// Handles sending messages, interacting with services, and managing loading state.
// It interacts primarily with ChatHistoryService to modify chat state.

class ChatController extends StateNotifier<AsyncValue<void>> {
  final Ref ref;

  ChatController(this.ref) : super(const AsyncData(null)); // Use AsyncValue for loading/error state

  // --- Core Action: Send Message ---
  Future<void> sendMessage(String text) async {
    state = const AsyncLoading(); // Indicate processing start

    final historyService = ref.read(chatHistoryServiceProvider);
    final settings = ref.read(settingsServiceProvider);
    final chatService = ref.read(openAIChatServiceProvider);
    final titleService = ref.read(titleGeneratorServiceProvider);

    // 1. Get Active Chat or Start New One
    String? currentSessionId = historyService.activeChatId;
    ChatSessionItem? currentSession;

    final historyEnabled = settings.historychatenabled;

    if (historyEnabled) {
       currentSession = historyService.getSessionById(currentSessionId!);
       if (currentSession == null){
           debugPrint("Active session ID $currentSessionId not found in history. Starting new chat.");
           currentSession = historyService.startNewChat();
           currentSessionId = currentSession.id;
       }
         } else {
      // History is disabled - operate on a temporary in-memory session
      // For simplicity here, we'll just prevent sending if history disabled.
      // A more complex implementation would manage a temporary message list.
      debugPrint("Chat history is disabled. Cannot send message.");
      state = AsyncError("Chat history is disabled", StackTrace.current);
       ref.read(isLoadingProvider.notifier).state = false; // Ensure loading is off
      return;
    }


    // 2. Create User Message
    final userMessage = ChatMessage(
      // id: uuid.v4(), // ID generated by constructor
      sender: MessageSender.user,
      content: text,
      timestamp: DateTime.now(),
    );

    // 3. Update State Immediately (Add user message to History Service)
      ref.read(isLoadingProvider.notifier).state = true;
      try {
          await historyService.addMessageToSession(currentSessionId!, userMessage);
          // Get the updated session after adding the message
          currentSession = historyService.getSessionById(currentSessionId);

      } catch (e,s) {
          debugPrint("Error adding user message to session: $e\n$s");
          state = AsyncError("Failed to save user message", s);
           ref.read(isLoadingProvider.notifier).state = false;
          return;
      }


    // 4. Generate Title (if enabled, first message, and history enabled)
    final bool isFirstUserMessage = currentSession?.messages.where((m) => m.sender == MessageSender.user).length == 1;
    if (settings.autotitle && isFirstUserMessage && historyEnabled) {
        try {
             debugPrint("Generating title for session $currentSessionId...");
            final generatedTitle = await titleService.generateTitle(text);
            await historyService.updateSessionTitle(currentSessionId, generatedTitle);
             debugPrint("Title generated: $generatedTitle");
        } catch (e) {
             debugPrint("Title generation failed: $e");
             // Continue without blocking chat
        }
    }


    // 5. Prepare API Call
     final List<ChatMessage> messagesForApi;
      if (settings.historyformodelsenabled && historyEnabled){
           // Send buffer size from history (or all if buffer is large)
           final buffer = settings.historybufferlength;
           messagesForApi = ((currentSession!.messages.length <= buffer || buffer == 0)
                              ? currentSession.messages
                              : currentSession.messages.sublist(currentSession.messages.length - buffer));
      } else {
          // Send only the last user message if model history is off
          messagesForApi = [userMessage];
      }

    // Add system prompt if defined
     final systemPrompt = settings.systemInstruction;
     List<OpenAIChatCompletionChoiceMessageModel> openAIMessages = [];
     if (systemPrompt.isNotEmpty) {
         openAIMessages.add(OpenAIChatCompletionChoiceMessageModel(
             role: OpenAIChatMessageRole.system,
             content: [OpenAIChatCompletionChoiceMessageContentItemModel.text(systemPrompt)]
         ));
     }
      openAIMessages.addAll(messagesForApi.map((msg) => chatService.convertToOpenAIMessage(msg)));


    // 6. Call API
    try {
       final response = await chatService.generateChatCompletion(
          model: settings.defaultchatmodel, // Use selected model
          messages: openAIMessages,
          temperature: settings.temperature,
          maxTokens: settings.maxOutputTokens > 0 ? settings.maxOutputTokens : null, // Handle 0 case
          topP: settings.topP,
          // TODO: Add other parameters like tools, topK if needed from settings
      );


        // 7. Process Response and Update State
       // TODO: Handle potential tool calls from the response if implemented
       // if (response.choices.first.message.haveToolCalls) { ... }

       final aiContent = response.choices.first.message.content?.first.text ?? "AI Response was empty.";

       final aiMessage = ChatMessage(
          sender: MessageSender.ai,
          content: aiContent,
          timestamp: DateTime.now(),
          metadata: { // Optional: Add API response metadata
              'model': response.choices.first.message,
              'finish_reason': response.choices.first.finishReason,
              'usage': response.usage,
          }
      );

       // Add AI message to history (if enabled)
       if (historyEnabled) {
           await historyService.addMessageToSession(currentSessionId, aiMessage);
       } else {
           // Handle displaying AI message if history is off (e.g., temporary list)
       }

       state = const AsyncData(null); // Signal success

    } catch (e, s) {
        debugPrint("Error sending message to AI: $e\n$s");
        state = AsyncError("AI Error: $e", s);

         // Add error message to chat (if history enabled)
        if (historyEnabled) {
             final errorMessage = ChatMessage(
                sender: MessageSender.system,
                content: "Error: Failed to get response.\n${e.toString()}",
                timestamp: DateTime.now(),
                metadata: {'error': true}
            );
           try {
                 await historyService.addMessageToSession(currentSessionId, errorMessage);
           } catch (histErr) {
                debugPrint("Failed to add error message to history: $histErr");
           }
        }

    } finally {
        // 8. Clear Loading State
        ref.read(isLoadingProvider.notifier).state = false;
    }
  }

  // --- Other Actions ---

  void createNewChat() {
    final historyEnabled = ref.read(chatHistoryEnabledProvider);
    if (!historyEnabled) {
       debugPrint("Cannot create new chat: History is disabled.");
       // Optionally show a message to the user
       return;
    }
     // startNewChat handles adding to list and setting active ID
     ref.read(chatHistoryServiceProvider).startNewChat();
  }

  void selectChat(String sessionId) {
     final historyEnabled = ref.read(chatHistoryEnabledProvider);
      if (!historyEnabled) {
           debugPrint("Cannot select chat: History is disabled.");
           return;
      }
     // setActiveChatId handles checking existence and notifying
     ref.read(chatHistoryServiceProvider).setActiveChatId(sessionId);
  }

   void deleteChat(String sessionId){
        final historyEnabled = ref.read(chatHistoryEnabledProvider);
         if (!historyEnabled) {
              debugPrint("Cannot delete chat: History is disabled.");
              return;
         }
        ref.read(chatHistoryServiceProvider).deleteChatSession(sessionId);
   }

}

final chatControllerProvider = StateNotifierProvider<ChatController, AsyncValue<void>>((ref) {
  return ChatController(ref);
});